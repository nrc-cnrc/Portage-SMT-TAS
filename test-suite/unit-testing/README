Traitement multilingue de textes / Multilingual Text Processing
Technologies de l'information et des communications /
   Information and Communications Technologies
Conseil national de recherches Canada / National Research Council Canada
Copyright 2008-2016, Sa Majeste la Reine du Chef du Canada
Copyright 2008-2016, Her Majesty in Right of Canada

Distributed under specific licensing terms.  Please refer to your signed
license agreement for details.


                            PortageII unit-testing

This directory contains a collection of ad hoc unit test suites.  These suites
typically take too long or are too complex to integrate them into the unit
testing framework we use in the src/ subdirectory.  Some of these test suites
are self verifying and automated via a run-test.sh script.  These get exercised
if you run ./run-all-tests.sh.  Others are only partially automated and require
manual analysis.

After installing PortageII, you can run the automated test suites by invoking
./run-all-tests.sh.  If all tests pass, great.  If not, differences in floating
point rounding between your architecture and ours is a likely cause, and might
not indicate an real problem.  In particular, these test suites are known to be
especially sensitive to floating point variance: align.posteriors, joint2cond,
hmm-*, rescoring.metric. 

Contents of this directory
==========================

Scripts:
 - run-all-tests.sh     Master script running all fully automated suites.
 - clean-all-tests.sh   Clean up after running test suites.

Test suites:
 - align.posteriors/    Test suite for the PosteriorAligner.
 - canoe.compress.output/  Make sure different ways of creating n-best produce
                        the same results.
 - compile_truecase_map/  Test suite for compile_truecase_map.
 - configtool/          Test suite for configtool.
 - filter-distortion-model/  Test suite for filter-distortion-model.
 - filter_models/       Test suite for filter_models.
 - hmm-classes/         Test suite for the class-conditioned variant of the HMM
                        word alignment module.
 - hmm-lex/             Test suite for the lexically conditioned variant of the
                        HMM word alignment module.
 - hmm-sym/             Test suite for symmetrized training of HMM word
                        alignment models.
 - joint2cond/          Test suite for joint2cond_phrase_tables, including its
                        -reduce-mem and -prune1 options.
 - lm/                  Test suite for using our various LM file formats and
                        filtering options.
 - lm.train_mixture/    Test suite for train_lm_mixture.
 - markup_canoe_output/ Test suite for the tools of tags transfer from source
                        to target text.
 - merge_counts/        Test suite for merge_counts and its uses for parallel
                        counting of phrase tables and LMs.
 - portage_utils.pm/    Test suite for Perl magic streams
 - rescoring.metric/    Test suite for using PER or WER in cow.sh.
 - r-parallel-d.pl/     Test suite for the run-parallel deamon's ability to
                        detect when its parent has disappeared and then exit.
 - run-parallel.io/     Test STDERR and STDOUT capturing in run-parallel.sh.
 - run-parallel.local-workers/  Test the choosing of the number of workers in
                        the master job under varying circumstances.
 - run-parallel.RP_PSUB_OPTS/  Make sure RP_PSUB_OPTS=... works correctly.
 - script.ff/           Test suite for the SCRIPT: rescoring feature.
 - strip_non_printing/  Test suite for strip_non_printing.
 - tokenize.pl/         Test suite for recent enhancements to our tokenizer.
 - toy/                 *** OBSOLETE *** Complete use of the PORTAGEshared 1.0
                        through 1.2 software suite on a tiny corpus, with
                        parameters chosen to run very fast (*not* recommended
                        as an experimental starting point).
 - translate.pl/        Test suite for doing the whole translation pipeline
 - truecasing/          Test suite for truecasing.
 - tune.py/             Test suite for decoder weight tuning
 - unal/                Test suite for decoder features counting unaligned words
 - wc_stats/            Test suite for our enhanced word counter
 - word_align_tool/     Test suite for word_align_tool.


Types of unit tests in PortageII
================================

There are two types of unit tests in PortageII:

 - The CxxTest tool is used to create closely integrated unit tests, calling
   individual functions, linked with your code directly.  These are found in
   the src/ hierarchy, under tests/ subdirectories and are exercised when you
   run "make test" in the PortageII/src/ directory.  See the annotated example
   in src/utils/tests/test_your_class.h for further details.

 - This directory is used to create loosely integrated unit tests, calling your
   actual programs via scripts and/or Makefiles.


Running the unit tests
======================

The unit tests in this directory are exercised by the nightly autobuild, and
can be launched manually this way:
   ./run-all-tests.sh -j 30
This will launch all tests, 30-ways parallel, and report on the success or
failure of each test.

On a non-clustered machine, you probably want to use -j with a third to half
the number of hyperthreaded cores on the machine (e.g., -j 12 to 15 on a
machine with 16 cores hyperthreaded to 32 apparent cores).

To clean up all tests, you can run
   ./clean-all-tests.sh


Minimum requirements
====================

In order for a unit test to work properly in this directory, you should:

1. Create an executable file called run-test.sh which runs the test and exits
with a 0 status on success, non-0 status on failure.  Doing so will make
./run-all-tests.sh run your test and report on its success or failure.

2. Create a Makefile that contains at least this code:
   TEMP_FILES=<list of temp files that might be created when the test is run>
   TEMP_DIRS=<list of temp directories that might be created when the test is run>
   include ../Makefile.incl
Doing so will give you a "clean" target so that "make clean" will remove all
temporary files, and it will give you a "gitignore" target that is
automatically called by "make all" so that Git will not see these temporary
files as untracked.  You can omit TEST_FILES or TEMP_DIRS if you don't create
temporary files or directories, but you should still include ../Makefile.incl
in all cases.

3. Write some unit tests.

If you write your unit test in the Makefile, make sure the "all" target runs
them. A typical run-test.sh file might then simply say
   make clean
   make all

If you write your unit tests in bash, your run-test.sh file should first say
   make gitignore
and then proceed to run your tests.


Parallelism guidelines
======================

It is strongly recommended to make each test suite finish in just a few
seconds, if possible.

A quick test suite should not be parallel (use "make all" without -j in
run-test.sh).

A slow test should use some parallelism, with the level of parallelism
chosen to minimize the total run time of
   ./run-all-tests.sh -j N
with N between a third and half the number of hyperthreaded cores on a
non-clustered machine.

A slow test can also detect when it's running on a cluster and maximize
parallelism in that case. See tune.py/run-test.sh for an example.


Additional suggestions
======================

Many test suites put their input data in a subdirectory called src/, and their
reference output in ref/.

The typical way to check for correctness is to manually inspect the output
while you create the test suite, save it in ref/ once you're happy with it, and
use diff for automatic subsequent validation.

