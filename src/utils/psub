#!/bin/bash
# $Id$

# psub - wrapper for qsub intended to do, by default, what we usually want,
#        and to simplify options we often use.
#        This script is intended to contain all the local peculiarities of the
#        clusters we use.  Other sites using Portage or PORTAGEshared may need
#        to adapt this script to their own cluster environment.
#
# PROGRAMMER: Eric Joanis
# COMMENTS:
#
# Technologies langagieres interactives / Interactive Language Technologies
# Institut de technologie de l'information / Institute for Information Technology
# Conseil national de recherches Canada / National Research Council Canada
# Copyright 2006, Sa Majeste la Reine du Chef du Canada /
# Copyright 2006, Her Majesty in Right of Canada

usage() {
   for msg in "$@"; do
      echo $msg >&2
   done
   cat <<==EOF== >&2

Usage: psub [options] <command line>

   Wrap <command line> into a PBS script and qsub it.

Options:

   -h(elp)        print this help message
   -v(erbose)     print the qsub script before submitting it
   -N <job name>  specify job name
   -#             use # CPUs on a node (nodes with # CPUs must exist)
                  thus getting access to more memory.
   -e <filename>  stderr destination
   -o <filename>  stdout destination
   -noscript      don't write out the script
   -l <resources> resources for job (man pbs_resources) (may be repeated)
   -nodes <properties>  properties the node should have; separate multiple
                  properties with ":", e.g., -nodes c2:blz0:big
   -qsparams <qsub parameters>  additional qsub parameters
   -p <priority>  set the job priority; on some systems, queued jobs with
                  higher priority start first. 0 = normal, >0 = high, <0 = low.
                  Only use > 0 for short, urgent jobs. [0]
   -n             "not really" (dump the PBS script, but don't submit it)
   -f             force submission even if errors are detected
   -I             enter interactive mode thus getting a prompt to a node
   -P <mins>      Log memory usage of process tree every <mins> minutes. [6]

Further notes:

   -on Venus, to enable node borrowing, use "-l ckpt=1".
   -on Venus, to request a minimum amount of memory, use, e.g., "-l mem=1800m"

==EOF==

   exit 1
}

error_exit() {
   for msg in "$@"; do
      echo $msg >&2
   done
   echo "Use -h for help." >&2
   exit 1
}

arg_check() {
   if [ $2 -le $1 ]; then
      error_exit "Missing argument to $3 option."
   fi
}

if which qsub >& /dev/null; then
   true # qsub found - we're running on a cluster
else
   error_exit "Can't find qsub, we don't seem to be running on a cluster."
fi

if uname -n | egrep -q 'balzac|blz'; then
   BALZAC=1
elif uname -n | egrep -q 'venus|vns'; then
   VENUS=1
else
   echo Running on an unknown cluster, I hope things are compatible... >&2
fi

PSUB_CMD="$0 $*"
CPU_COUNT=1
MEMORY_POLLING_DELAY=6

while [ $# -gt 0 ]; do
   case "$1" in
   -h|-help)            usage;;
   -v|-verbose)         VERBOSE=1;;
   -N)                  arg_check 1 $# $!; NAME=$2; shift;;
   -[1-9]|-[1-9][0-9])  CPU_COUNT=$((0 - $1));;
   -I)                  INTMODE=1; NOSCRIPT=1;;
   -e)                  arg_check 1 $# $!; ERR_FILE=$2; shift;;
   -o)                  arg_check 1 $# $!; OUT_FILE=$2; shift;;
   -P)                  arg_check 1 $# $!; MEMORY_POLLING_DELAY=$2; shift;;
   -noscript)           NOSCRIPT=1;;
   -l)                  arg_check 1 $# $!
                        if [ -n "$RESOURCES" ]; then RESOURCES="$RESOURCES,$2"
                                                else RESOURCES="$2"
                        fi
                        shift;;
   -nodes)              arg_check 1 $# $!; NODES=$2; shift;;
   -qsparams)           arg_check 1 $# $!; QSPARAMS=$2; shift;;
   -p)                  arg_check 1 $# $!; PRIORITY=$2; shift;;
   -n)                  NOT_REALLY=1;;
   -f)                  FORCE=1;;
   --)                  shift; break;;
   -*)                  error_exit "Unknown options $1.";;
   *)                   break;;
   esac
   shift
done

COMMAND="$*"

# We are in interactive mode thus we need to reserve the entire node
if [ -n "$INTMODE" ]; then
   if [ $CPU_COUNT -gt 2 ]; then
      CPU_COUNT=4
   else
      CPU_COUNT=2
   fi
fi

if [ -z "$COMMAND" -a ! -n "$INTMODE" ]; then
   error_exit "Missing command, nothing to run!"
fi

# Guess the executable program or script name
PROG_NAME=`echo "$COMMAND" | perl -e '
   $_ = <>;
   chomp;
   # Use STDIN as the job name of the command seems empty
   $_ or $_ = "STDIN";
   @tokens = split;
   print $tokens[0];
'`

# If the command is a script but doesn't have its x permission bit set,
# call it with its interpreter
if [ -f $PROG_NAME -a ! -x $PROG_NAME -a ! "$FORCE" ]; then
   if file $PROG_NAME | grep -q "script text"; then
      # file is a script
      HASH_BANG_LINE=`head -1 $PROG_NAME`
      INTERPRETER=${HASH_BANG_LINE/#\#\!}
      INTERPRETER=${INTERPRETER%% *}
      if which "$INTERPRETER" >& /dev/null; then
         echo Calling your script with "$INTERPRETER"
         COMMAND="$INTERPRETER $COMMAND"
      else
         echo "\"$PROG_NAME\" seems to be a $INTERPRETER script, but \"which\" can't find $INTERPRETER."
         echo "Make your script executable, fix it, or use -f to submit your command as is"
         exit 1
      fi
   else
      echo "\"$PROG_NAME\" is neither executable nor a script."
      echo "Use -f if you really mean to submit your command as is."
      exit 1
   fi
fi

# Determine the default job name if -N is not specified on the command line.
if [ ! $NAME ]; then
   NAME=`basename $PROG_NAME`
fi

# Make sure $NAME is not longer that 15 characters, and starts with a letter
NAME=`echo $NAME | perl -e '
   $_ = <>;
   chomp;
   s/^([^a-z])/J$1/i;
   print substr($_, 0, 15);
'`

if [ $RESOURCES ]; then
   OLDRESOURCES="$RESOURCES,"
else
   OLDRESOURCES=""
fi

if [ $CPU_COUNT -gt 1 ]; then
   RESOURCES="${OLDRESOURCES}nodes=1:ppn=$CPU_COUNT"
fi

# Allow one thread per CPU for OpenMP.
PORTAGE_OPENMP_NUMBER_THREADS=$CPU_COUNT

if [ -n "$NODES" ]; then
   if [ -n "`echo $RESOURCES | grep nodes= 2> /dev/null`" ]; then
      RESOURCES=$RESOURCES:$NODES
   elif [ -n "$RESOURCES" ]; then
      RESOURCES=$RESOURCES,nodes=$NODES
   else
      RESOURCES=nodes=$NODES
   fi
fi

# qsub options we always use: -r n: not rerunable; -N $NAME: name the job
QSUB_CMD="qsub -r n -N $NAME"
test -n "$QSPARAMS" && QSUB_CMD="$QSUB_CMD $QSPARAMS"
test -n "$RESOURCES" && QSUB_CMD="$QSUB_CMD -l$RESOURCES"
test -n "$PRIORITY" && QSUB_CMD="$QSUB_CMD -p $PRIORITY"
if [ -n "$INTMODE" ]; then
   test -n "$INTMODE" && QSUB_CMD="$QSUB_CMD -I"
   echo "Entering interactive mode"
   if [ $NOT_REALLY ]; then
      echo $QSUB_CMD
   else
      $QSUB_CMD
   fi
   exit
fi

test -n "$ERR_FILE" && QSUB_CMD="$QSUB_CMD -e $ERR_FILE"
test -n "$OUT_FILE" && QSUB_CMD="$QSUB_CMD -o $OUT_FILE"

TMPSCRIPT=/tmp/psub.`whoami`.`date +%s`.$$
trap "rm -f $TMPSCRIPT $TMPSCRIPT.jobid; exit" 0 2 3 13 14 15

cat <<==EOF== > $TMPSCRIPT
#!/bin/bash

# Preserve important parts of the calling environment
export PATH=\$PBS_O_PATH
==EOF==

env | grep PORTAGE | sed 's/^/export /' >> $TMPSCRIPT
for var in LD_LIBRARY_PATH PERL5LIB PYTHONPATH MANPATH; do
   if [ "`env | grep ^$var=`" != "" ]; then
      echo "export "`env | grep ^$var=` >> $TMPSCRIPT
   fi
done

cat <<==EOF== >> $TMPSCRIPT

# Preserve the calling working directory
cd \$PBS_O_WORKDIR

# Set the number of allowed openmp threads based on the number of cpus.
export OMP_NUM_THREADS=$PORTAGE_OPENMP_NUMBER_THREADS

# Display the exact start time
echo Starting on \`date\` on node \`hostname\` >&2

# Periodically monitor the memory usage of the process tree, since PBS does not
# do so reliably.
process-memory-usage.pl $(($MEMORY_POLLING_DELAY*60)) \$\$ >&2 &

# User command
$COMMAND

# Display resources used on stderr when the user command has completed
echo Finished on \`date\` >&2
qstat -f \$PBS_JOBID | egrep '\b(Job Id|resources_used|comment)\b' >&2

# qsub command executed
# $QSUB_CMD $TMPSCRIPT

# original psub command given by user (with quotes and \\ removed)
# $PSUB_CMD
==EOF==

if [ $VERBOSE ]; then
   cat $TMPSCRIPT
   echo ""
fi

if [ $NOT_REALLY ]; then
   cat $TMPSCRIPT
   echo ""
   exit
fi

$QSUB_CMD $TMPSCRIPT > $TMPSCRIPT.jobid
JOBID=`cat $TMPSCRIPT.jobid`
SHORTJOBID=${JOBID%%[ ./]*}
echo $JOBID

if [ ! $NOSCRIPT ]; then
   cp $TMPSCRIPT $NAME.j${SHORTJOBID:-0}
fi
