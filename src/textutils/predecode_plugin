#!/bin/bash
#
# @file predecode_plugin
# @brief Default pre-decoder plugin
#
# @author Michel Simard
#
# COMMENTS:
#
# Technologies langagieres interactives / Interactive Language Technologies
# Inst. de technologie de l'information / Institute for Information Technology
# Conseil national de recherches Canada / National Research Council Canada
# Copyright 2010, Conseil national de recherches du Canada /
# Copyright 2010, National Research Council of Canada

## 
## Usage: predecode_plugin SRC_LANG < in > out
## 
## Default predecoding plugin: to be called immediately prior to
## decoding (but after tokenization, lowercasing, etc.).
## Among other things, the predecoding plugin must apply the rules parser.
##

if [ "$1" == "-help" -o "$1" == "-h" ]; then
    cat $0 | grep "^##" | cut -c4-
    exit 1
fi

test $# -eq 0 && echo "Missing language code argument" >&2 && exit 1
SOURCE_LANGUAGE=$1; shift

# If you have a rules parser, replace the canoe-escapes.pl call by a call to your
# rules parser. The rules parser must also escape literal use of the following 
# characters in the input text: '<', '>', '\'.
canoe-escapes.pl -add | utf8_filter


# The following sample code maps numbers of the following forms, from English
# to French:
#  - 420K -> 420 000
#  - 12,345,678.90 -> 12 345 678,90
#  - An optional + or - in front is allowed and preserved
#  - The number has to be the whole token, so that we don't accidentally grab
#    longer codes
#  - The number has to be in groups of three: 4-digit years will not be
#    touched.
# To activate, uncomment the following block of lines, and comment out the
# "canoe-escapes.pl" line above.
#[[ $SOURCE_LANGUAGE != en ]] && echo "This number parser only works with English input" && exit 1
#perl -ple '
#   s/([\\<>])/\\\1/g; # escape \, < and >
#   s/(^|\ )([-+]?\d{1,3}(?:,\d{3})*)(k|\.(?:\d{3},)*\d{1,3}|(\.\d{1,3})?(m))?(?=\ |$)/
#      $1 .
#      "<NUMK target=\"" .
#      join(" ", (map { $num = $_; $num =~ s#,# #g; $num } ($2))) .
#      ($3 eq "k"
#         ? " 000"
#         : ($5 eq "m"
#            ? join(" ", (map { $num = $_; $num =~ s#^\.#,#; $num } ($4))) . " millions"
#            : join(" ", (map { $num = $_; $num =~ s#,# #g; $num =~ s#^\.#,#; $num } ($3)))
#           )
#      ) .
#      "\">$2$3<\/NUMK>" .
#      $6
#    /exg;
#' | utf8_filter
